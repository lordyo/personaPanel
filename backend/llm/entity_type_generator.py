"""
Entity Type Generator DSPy module for the Entity Simulation Framework.

This module defines the DSPy module for generating entity type dimensions based on name and description.
"""

import dspy
from typing import Dict, List, Any, Optional
import json
import time
import logging
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logger = logging.getLogger(__name__)

# Configure retry parameters
MAX_RETRIES = 3
RETRY_DELAY = 2  # seconds


class LLMError(Exception):
    """Exception raised for errors in LLM API calls."""
    pass


def retry_on_error(func):
    """
    Decorator to retry LLM API calls on failure.
    
    Args:
        func: Function to decorate
        
    Returns:
        Wrapped function with retry logic
    """
    def wrapper(*args, **kwargs):
        retries = 0
        while retries < MAX_RETRIES:
            try:
                return func(*args, **kwargs)
            except Exception as e:
                retries += 1
                if retries < MAX_RETRIES:
                    logger.warning(f"Error in LLM call: {str(e)}. Retrying in {RETRY_DELAY} seconds...")
                    time.sleep(RETRY_DELAY)
                else:
                    logger.error(f"Maximum retries reached. Last error: {str(e)}")
                    raise LLMError(f"Failed after {MAX_RETRIES} attempts: {str(e)}")
    return wrapper


class EntityTypeDimensionsSignature(dspy.Signature):
    """Generate dimensions for an entity type based on name and description."""
    
    entity_type_name: str = dspy.InputField(
        desc="The name of the entity type to generate dimensions for"
    )
    entity_type_description: str = dspy.InputField(
        desc="A detailed description of the entity type, explaining what it represents"
    )
    n_dimensions: int = dspy.InputField(
        desc="Number of dimensions to create for this entity type"
    )
    
    dimensions: List[Dict[str, Any]] = dspy.OutputField(
        desc="""JSON list of dimensions, where each dimension has:
        - name: The name of the dimension
        - description: A description of what this dimension represents
        - type: The type of dimension (boolean, categorical, int, float, text)
        - options: List of options for categorical dimensions (only for categorical type)
        - min_value: Minimum value for int/float dimensions (only for int/float types)
        - max_value: Maximum value for int/float dimensions (only for int/float types)
        - distribution: Distribution type for int/float dimensions ("uniform", "normal", "skewed") 
                       or percentage for boolean ("percentage")
        """
    )


def normalize_dimensions(dimensions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Normalize dimensions to ensure compatibility with entity type creation.
    
    This function adds missing fields and makes adjustments to ensure
    the dimensions work with the entity type creation endpoint.
    
    Args:
        dimensions: List of dimensions as generated by LLM
        
    Returns:
        Normalized list of dimensions compatible with the API
    """
    normalized = []
    
    for dim in dimensions:
        normalized_dim = {
            "name": dim.get("name", ""),
            "description": dim.get("description", ""),
            "type": dim.get("type", "")
        }
        
        dim_type = dim.get("type", "")
        
        # Handle categorical dimensions
        if dim_type == "categorical":
            normalized_dim["options"] = dim.get("options", [])
            # Add distribution_values if not present (equal distribution by default)
            if not dim.get("distribution_values") and dim.get("options"):
                options = dim.get("options", [])
                if options:
                    equal_prob = 1.0 / len(options)
                    normalized_dim["distribution_values"] = {option: equal_prob for option in options}
        
        # Handle numerical dimensions (int, float)
        elif dim_type in ["int", "float", "numerical"]:
            normalized_dim["min_value"] = dim.get("min_value", 0)
            normalized_dim["max_value"] = dim.get("max_value", 100)
            
            # Default to uniform distribution if not specified
            normalized_dim["distribution"] = dim.get("distribution", "uniform")
            
            # Add spread_factor for normal distribution if not present
            if normalized_dim["distribution"] == "normal" and not dim.get("spread_factor"):
                normalized_dim["spread_factor"] = 0.5
            
            # Add skew_factor for skewed distribution if not present
            if normalized_dim["distribution"] == "skewed" and not dim.get("skew_factor"):
                normalized_dim["skew_factor"] = 0.0
        
        # Handle boolean dimensions
        elif dim_type == "boolean":
            # Convert options to proper boolean dimension format if it exists
            if dim.get("options") and len(dim.get("options", [])) == 2:
                normalized_dim["options"] = None  # Remove options, as boolean doesn't use it
            
            # Add true_percentage if not present
            normalized_dim["distribution"] = "percentage"
            normalized_dim["true_percentage"] = dim.get("true_percentage", 0.5)
        
        # Handle text dimensions - nothing special needed
        
        normalized.append(normalized_dim)
    
    return normalized


class EntityTypeDimensionsGenerator:
    """
    Class for generating entity type dimensions using DSPy.
    
    This class provides methods for generating dimensions for entity types
    and can be easily integrated with API routes.
    """
    
    def __init__(self):
        """Initialize the generator with DSPy configuration."""
        self._configure_dspy()
        # Use ChainOfThought for better reasoning
        self.generator = dspy.ChainOfThought(EntityTypeDimensionsSignature)
    
    def _configure_dspy(self):
        """Configure DSPy with the OpenAI language model."""
        # Get the API key
        api_key = os.environ.get('OPENAI_API_KEY')
        if not api_key:
            raise EnvironmentError("OPENAI_API_KEY environment variable not set")
        
        # Configure DSPy with OpenAI
        model_name = os.environ.get('DSPY_MODEL', 'gpt-4o-mini')
        
        # Create the language model
        lm = dspy.LM(f'openai/{model_name}', 
                    api_key=api_key,
                    temperature=0.7,
                    max_tokens=2000)
        
        # Configure DSPy
        dspy.configure(lm=lm)
    
    @retry_on_error
    def generate_dimensions(self, entity_type_name: str, entity_type_description: str, n_dimensions: int = 5, normalize: bool = True) -> List[Dict[str, Any]]:
        """
        Generate dimensions for an entity type.
        
        Args:
            entity_type_name: Name of the entity type
            entity_type_description: Description of the entity type
            n_dimensions: Number of dimensions to generate (default: 5)
            normalize: Whether to normalize dimensions for API compatibility (default: True)
            
        Returns:
            List of dimension dictionaries
        
        Raises:
            LLMError: If there's an error with the LLM API call
            ValueError: If the generated dimensions are not in the expected format
        """
        try:
            logger.info(f"Generating dimensions for entity type: {entity_type_name}")
            
            # Make the prediction
            prediction = self.generator(
                entity_type_name=entity_type_name,
                entity_type_description=entity_type_description,
                n_dimensions=n_dimensions
            )
            
            # Extract dimensions from prediction
            dimensions = prediction.dimensions
            
            # Validate the dimensions format
            if not isinstance(dimensions, list):
                logger.error(f"Invalid dimensions format: {dimensions}")
                raise ValueError("Generated dimensions are not in list format")
            
            # Normalize dimensions if requested
            if normalize:
                dimensions = normalize_dimensions(dimensions)
            
            logger.info(f"Successfully generated {len(dimensions)} dimensions for {entity_type_name}")
            return dimensions
            
        except Exception as e:
            logger.error(f"Error generating dimensions: {str(e)}")
            raise LLMError(f"Failed to generate dimensions: {str(e)}")


# Create a singleton instance for easy import
generator = EntityTypeDimensionsGenerator()


def generate_entity_type_dimensions(entity_type_name: str, entity_type_description: str, n_dimensions: int = 5, normalize: bool = True) -> List[Dict[str, Any]]:
    """
    Generate dimensions for an entity type using the singleton generator.
    
    Args:
        entity_type_name: Name of the entity type
        entity_type_description: Description of the entity type
        n_dimensions: Number of dimensions to generate (default: 5)
        normalize: Whether to normalize dimensions for API compatibility (default: True)
        
    Returns:
        List of dimension dictionaries
    
    Raises:
        LLMError: If there's an error with the LLM API call
        ValueError: If the generated dimensions are not in the expected format
    """
    return generator.generate_dimensions(
        entity_type_name=entity_type_name,
        entity_type_description=entity_type_description,
        n_dimensions=n_dimensions,
        normalize=normalize
    ) 